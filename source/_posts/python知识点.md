---
title: python知识点.md
date: 2020-01-14 10:20:01
tags:  [python,切片]
categories: python
toc: true
---

[TOC]

## Python介绍

### 文本编辑器:Sublime

### Python代码规范

```PYTHON
Python官方提的代码规范文档俗称PEP8:https://www.python.org/dev/peps/pep-0008/
谷歌中对应的中文文档地址： — Google 开源项目风格指南.html
```

### Python的口号：人生苦短，我用Python

### 编译器&解释器

```Python
编译器：计算机不能直接理解除机器语言以外的语言，将其他语言翻译成机器语言的工具成为编译器；
编译器翻译的方式有两种，一种是编译，另一种是解释，两种方式之间的区别在于翻译时间点的不同，当编译器以解释方式运行时，也称之为解释器；
```

### 编译型语言和解释型语言的区别

```PYTHON
编译型语言:c / c++
特点: 执行速度快
缺点: 跨平台性比较差
    
解释型语言:python
特点: 跨平台性比较好( 在linux系统可以运行, 还可以在windows上运行)
缺点: 执行速度比较慢(逐行解释每一句源代码)
```

### Python语言的特点

```PYTHON
1.完全面向对象(Python中一切皆对象)

2.具有强大的标准库(web网络通信, 数据库接口, 图形界面等)

3.具有很多的第三方库(科学计算, 人工智能, 数据分析, 机器学习等)
```

### Python的优缺点

```PYTHON
优点:简单,易学；免费,开源(源代码公开)；面向对象；有丰富的库；可扩展性(可以调用C/C++语言,java语言的库)
    
缺点:执行速度较慢
```

### Python环境部署

```PYTHON
版本要求
Pycharm：使用社区版或未破解版
Python解释器：使用64位3.6.6以上的版本

安装步骤：
1.下载Python解释器，鼠标右键，以管理员身份运行，是否允许程序对计算机进行修改：选择是；
2.安装时勾选添加系统环境变量（Add Path 3.6 TO Path），选择自定义安装(Customize Installation);
3.Optional Fixtures页面默认选择，点击Next直接下一步；
4.Advanced Options页面，Browse自定义成C:\Python36,点击Install
5.安装结束点击close

Python 解释器验证步骤:
Mac:在终端中直接输入Python回车，如果有刚刚安装的解释器即安装成功
Windows:
    1,开始菜单搜索“cmd”，启动 cmd
    2.输入 python回车
    3.如果有刚刚安装的解释器即安装成功
```

### Python源程序概念

```PYTHON
Python源程序就是一种特殊格式的文本文件，可以使用任意文本编辑器做Python开发；
Python文件的扩展名通常都是.py


实例：
1.在电脑上先创建任意一个格式的文本，然后将后缀改为.py；
2.用文本编辑器打开在文本中输入print("sdfgg")保存；
3.在终端中将路径切换到改文件所在目录输入命令 python 文件名；
```

### Pycharm

```PYTHON
概念：Python的IDE(IDE:集成开发环境)
工程名/项目名的命名规则：大驼峰或小驼峰(一个项目对应一个工程)
文件名命名规则：小写字母，数字，下划线组成
```

### 注释

```PYTHON
单行注释：#
1.在代码上方进行单行注释(#与说明文字之间敲一个英文空格，保证代码的可读性)
2.在代码右边进行单行注释(注释与代码之间敲两个英文空格，保证代码的可读性)
多行注释："""注释的内容"""or'''注释的内容'''
 当代码需要的注释一行写不完的时候，用多行注释
```

### 多行同时右移，左移的快捷键

```PYTHON
1，先选中要缩进的代码
2.按tab键，一次缩进4个空格；tab+shift键，左移4个空格
```



### 运算符

```PYTHON
+ - * / //(取整除) %(取余) **(幂)

优先级：先乘除后加减，同级从左向右开始计算，()可以改变计算顺序
```

### 计算机中的三大件

```PYTHON
CPU：负责处理数据和计算
内存：存储空间小，运行速度快，临时存储，价格高
硬盘：存储空间大，运行速度慢，永久存储，价格低
程序的执行过程：程序执行之前是保存在硬盘中，当要运行一个程序时，操作系统会先让CPU把程序复制到内存中，CPU执行内存中的程序代码
```

### 变量

```PYTHON
程序是用来执行数据的，变量是用来存储数据的

定义变量：变量名  = 值

使用变量
直接使用变量名
print(变量名)
注意：变量中数据值是可以修改的，变量名第一次出现叫做定义, 之后使用的变量名叫做使用定义后的变量

python交互模式：
1.打开终端，输入Python回车
2.定义一个变量并给其赋值，回车
3.输入变量名，回车

```

### 变量的类型

```PYTHON
1.数字类型:int (整数类型)，float(浮点数类型)
bool(布尔类型)
 True  (真)  非0数字
 False(假)   数字0

2.非数字类型:字符串(str)，列表(list)，元组( tuple )，字典 (dict)
    
type()函数可以查看变量或数据的类型
使用方法：
type(变量名)      
type(数据)
```

### 变量之间的运算

```PYTHON
数字型的变量之间可以直接运算(运算时True=1，False=0)

非数字型：字符串可以相加, 就是字符串的拼接；int类型不能和str类型相加, 但是可以相乘, 让字符串重复指定的次数
```

### 变量的输入

```PYTHON
price=int(input('请输入苹果的价格：') ) # input输入的内容为字符串，需要强转,将字符串转成整数
weight=float(input('请输入苹果的重量'))  # 将字符串转为小数
money=price*weight
print(money)

int(x) 将x转换为int类型,但是 x 必须是整数型字符串

float(x)  将x转换为float类型,但是 x 可以是整数和浮点数类型字符串

str(x)  将x转换为字符串类型, 任何数据类型都可以转换为字符串类型
```

### 变量的格式化输出

```PYTHON
%s 字符串
%d 有符号⼗进制整数， %06d 表示输出的整数显示位数， 不⾜的地⽅使⽤ 0 补全
%f 浮点数， %.2f 表示⼩数点后只显示两位
%% 输出 % , 两个 %% 表示一个 %
例子：我的名字叫：小明,身高:1.75,体重:90,成绩在全班排名:6.00%
name="小明"
height=1.75
weight=90
rank=6.00
print("我的名字叫：%s,身高:%.2f,体重:%d,成绩在全班排名:%.2f%%" % (name,height,weight,rank))
```

### 标识符的命名规范

```PYTHON
标示符是由程序员定义的变量和函数的名字，需要起到见名知意的效果，命名规范：
 1.要由字母,数字和下划线组成
 2.不能以数字开头
 3.不能和Python中的关键字重名(关键字:Python具有特殊含义的标识符, 具有特殊的功能和含义；不能对Python中的     关键字 进行赋值)
在Pycharm中输入以下代码，可以查看Python中的关键字：
import keyword
print(keyword.kwlist)
```

### 变量的命名规则

```PYTHON
1.符合标识符的命名规范
2.符合命名法则
    ① 小驼峰命名法
      (第一个单词首字母小写, 后面每个单词的首字母大写)
    ② 大驼峰命名法
      (每个单词的首字母都要大写)
    ③ 下划线命名法
      (每个单词都是小写字母, 单词与单词之间使用下划线连接)
```

### IF语句

```PYTHON
##if...else条件判断语句

if  条件判断:
	满足条件时,执行代码1
else:
	不满足条件时, 执行代码2
    
注：条件判断可以使用逻辑运算符(and,or,not)

##if...elif...else条件判断语句
if 条件判断1:
	满足条件时, 执行代码1
	满足条件时, 执行代码2
elif  条件判断2:
	满足条件时, 执行代码3
elif  条件判断3:
	满足条件时, 执行代码4
else:
	上面条件都不满足, 则执行else部分缩进的代码	
 
##if嵌套
作用: 满足某个条件下, 进行额外的条件判断

if  条件判断1:
	满足条件1, 执行代码
	if  条件判断2:
		满足条件2, 执行代码
	else:
		不满足条件2时, 执行代码	
else:
	不满足条件1时, 执行代码

注:  内层条件判断2  必须满足在外层条件判断1的基础上

```

### 随机数模块

```PYTHON
1.导入模块  import random
2.使用 模块 random.randint(x,y)  
  注：1.random.敲一下tab键，会提示该模块中包含的所有函数
     2.取的数x<=a<=y,且x<=y，都为整数
```

### 运算符

```PYTHON
1.算数运算符
  +,-, *,/, //(取整除), %（取余）, **(幂)
2.比较运算符
  == (等于)
  !=(不等)
  >
  <
  >=
  <=
  比较运算符  常常和if条件判断一起使用
3.赋值运算符
  = 
  += , c += a 等效于 c = c + a
  -=
  *=
  /=
  //=
  %=
  **=, c **= a 等价于  c= c**a
4.逻辑运算符
  and
  or
  not 
  常常和if条件判断一起使用

5.运算符的优先级:
  算数运算符 > 比较运算符 > 赋值运算符  > 逻辑运算符
  运算符在一起使用时, 可以使用小括号() 调整运算符的优先级

```

### while循环

```PYTHON
1.作用: 让指定的代码重复执行
2.语法格式:
  ① 定义变量 记录循环次数(计数器)
  ② while  后面添加条件判断:
  ③ 满足条件时,执行缩进部分的代码
  ④ 在循环体内部修改变量, 便于下一次循环
3.死循环:
  死循环是一种现象, 在循环体内部没有修改循环变量,
  导致while 后面的条件判断一直成立,
  一直执行缩进部分的代码, 无法退出循环的现象
  注意: 要避免死循环, 在循环体内部修改变量, 便于下一次循环
        最终退出循环
4.循环体内部可以添加条件判断
##案例1：计算0-100之间所有数据的累计之和
i=0
sum=0
while i<=100:
    sum+=i
    i+=1
print(sum)
##案例2：计算0-100之间所有偶数的累计之和
i=0
sum=0
while i<=100:
    if i%2==0:
        sum+=i
    i+=1
print(sum)
##案例3：计算0-100之间所有奇数的累计之和
i=0
sum=0
while i<=100:
    if i%2!=0:
        sum+=i
    i+=1
print(sum)
```

### Python的计算法则

```PYTHON
1.自然计数法
  从1开始, 更符合人类的使用习惯
2.程序计数法
  从0开始, 更符合计算机编程的需求
推荐使用 程序计数法, 符合计算机编程的需求
```

### break和continue

```PYTHON
相似：两者都只能作用于当前循环
区别：
break作用于循环:
1.满足某个条件时,提前终止循环
2.循环体中break后面的语句不再执行
continue作用于循环:
1.满足条件时,并没有终止循环, 跳过本次循环,执行下一次循环
2.如果在修改循环变量,是在continue关键字之后, 容易出现死循环(建议修改循环变量,放在continue关键字之前)
##案例1
i=0
while i<=10:
    if i==7:
        break
    print(i)
    i+=1
##案例2
i=0
while i<=10:
    if i==7:
        i += 1
        continue
    print(i)
    i+=1
```

### while循环嵌套

```PYTHON
作用场景: 排序和一些特殊场景(平面坐标)用到
1.while循环中嵌套while循环
2.无论是外层循环还是内层循环,都要定义循环变量,记录循环次数
3.无论是外层循环还是内层循环,都要修改循环变量,便于下一次循环,最终退出循环
4.外层循环执行一次, 内层执行一圈
5.外层循环一般用来控制行(x轴)
  内层循环一般用来控制列(y轴)
##案例1：打印五行小星星，每一行的星星数量跟行数相同
i=1
while i<=5:
    j=1
    while j<=i:
        print("* ",end="")# 在循环内部不换行
        j+=1
    print("")# 每一次循环结束之后再进行换行
	 i+=1
##案例2：九九乘法表
i=1
while i<=9:
    j=1
    while j<=i:
        #print("j*i=i*j",end="")
        print("%dx%d=%d " %(j,i,j*i),end="\t")
        j+=1
    print("")
    i+=1
   注：转义字符
	  end="":表示输出结束后不换行
      end="\t":可以在控制台输出一个制表符，使输出的文本垂直方向保持对齐
     	"\n":在控制台输出一个换行符
    	"\r":回车
        \\:反斜杠符号
         \":双引号
         \'：单引号
```

### 函数

```PYTHON
1.格式：
def 函数名():
    封装的代码块
 注：def 是英文define的缩写；函数名需要符合标识符的命名规范且需要见名知意，函数名能够代表封装的代码功能，方便之后调用
2.作用: 实现某个功能的代码整体
3.定义函数, 把功能封装在函数中
4.调用函数, 享受封装的结果(函数名()就可以调用函数)
```

### 函数的使用

```PYTHON
函数的使用:
1.函数是具有独立功能的代码块,是一个整体(封装了函数功能的代码)
2.作用: 提高开发效率,实现代码的重用
3.函数使用的步骤:
  ① 定义函数: 把函数的功能封装成一个整体
  ② 调用函数: 享受封装的结果
4.函数调用流程注意点:
  ① 函数定义时 不会执行函数体中代码
  ② 函数调用时,才会执行函数体中代码
  ③ 函数调用完成以后,一定要回到函数调用的地方继续向下执行

```

### 函数中Pycharm的使用规范

```PYTHON
F8 Step over:单步调试
  ①  函数定义前面,没有加断点,调用函数时,把函数当成一行代码运行(不会进入函数体内部)
  ②  函数定义前面,有加断点,调用函数时,会进入函数内部执行代码
F7 Step into:单步进入
  一步一步执行代码,调用函数时,会进入函数内部执行代码
函数的注释小结:
1.作用: 对函数起到解释说明的作用,方便开发者阅读
2.在函数定义下方使用 """函数注释""", 三个成对双引号中间内容就是函数的注释
3.将光标放在函数调用地方,按住 ctrl + q（Windows）键可以查看函数的注释说明

##注：函数相对比较独立，定义函数的上方应和其他代码块之间空两行
```

### 函数的形参，实参和返回值

```PYTHON
##函数参数小结:
1.作用: 针对函数相同的处理逻辑,用户的需求不同,得到不同结果
2.在函数定义的时候,需要在函数括号中,添加参数, 在函数体中,将参数当做变量使用
3.在函数调用时,需要根据函数参数顺序,分别传入不同数据或变量
##函数的形参和实参:
1.形参: 定义函数时,用来接收函数调用传递过来的数据或变量,在函数体中函数形参当做变量一样使用
2.实参: 调用函数时,需要把传递给定义的函数体中变量或数据叫做实参
##函数的返回值:
1.作用: 当需要函数的运算结果时,需要函数的返回值
2.格式: return 返回结果 
3.return可以将函数运行结果返回到函数调用的地方
4.函数体中return后面的代码不再执行(可以使用return提前终止函数的运行)
5.函数体中return 后面没有返回结果,但是函数调用地方偏偏需要返回结果,
  python解释器会把None返回(什么都没有,与MySQL中NULL相似)
 例1：计算任意两个数之和
def sum2_num(num1,num2):
    return num1+num2
result=sum2_num(10,2)
print("两数之和：%d"% result)
```

### 函数的嵌套调用

```PYTHON
##案例1：一个函数中嵌套另一个函数
def test1():
    print("*"*10)
    print("test1")
    print("*" * 10)
def test2():
    print("*" * 20)
    print("test2")
    test1()
    print("*" * 20)
test2()
##案例2：打印五行，任意字符任意次数
def print_line(char,times):
    row=0
    while row<5:
        print(char*times)
        row+=1
print_line("*",20)
```

### 模块中的函数

```PYTHON
1.作用: 可以将python文件当做模块,供其他开发者导入使用
2.使用步骤:
  ① 导入模块
    import 模块名
  ② 使用模块中函数或变量 
    模块名.函数名(参数)    模块名.变量
3.模块名要符合标识符的命名规范
4.注意: 我们可以将功能稳定的代码封装到模块中,供其他人使用
    
实例：
file01.py中的代码
name="加法"
def add(a,b):
    return a+b
file02.py调用file01.py中的函数和变量
from study01 import add, name

result=add(10,20)
print(result)
print(name)
```

### 查看某类型中定义的方法

```PYTHON
1.在Pycharm的终端中先输入python3
2.dir(list/tuple/dict/str),按下回车
3.会提示列表/元组/字典/字符串能够使用的方法
```

###对列表的常见操作——增删改查

#### 增

```PYTHON
 1.列表.insert(索引, 数据) 在指定位置插入数据
 2.列表.append(数据) 在末尾追加数据
 3.列表.extend(列表2) 将列表2 的数据追加到列表 (把 列表2合并到列表1)
```

#### 删

```PYTHON
1.删除 del 列表[索引] 删除指定索引的数据
  拓展: del  my_list  将列表my_list从内存中清除, 连空书包都没有
2.列表.remove(数据) 删除第一个出现的指定数据
3.列表.pop() 删除末尾数据
4.列表.pop(索引) 删除指定索引数据
5.列表.clear() 清空列表
```

#### 改

```PYTHON
 1. 列表[索引] = 数据 修改指定索引的数据
```

#### 查

```PYTHON
 查
  1.列表[索引]  通过索引获取数据
  2.列表名.index(数据)  通过数据获取 索引(获取的是数据第一次出现索引)  
  3.统计 len(列表) 列表长度
  4.列表.count(数据) 数据在列表中出现的次数
  5.排序 列表.sort() 升序排序
  6.降序 列表.sort(reverse=True) 降序排序
  7.列表.reverse() 逆序、 反转(前面的额数据放到后面, 后面的数据放到前面)
```

## 循环遍历

```python
for循环:
1.作用: 用来遍历列表容器(元组,字符串,字典)
        for循环可以将列表中数据一个一个取出
2.语法:
  for  临时变量  in  集合:
        对临时变量的处理
  else:
    循环结束后要执行的代码
实例1：
list1=[1,2,3,4]
for i in list1:
    print(i)
实例2：
list1=(1,2,3,4)
for i in list2:
    print(i)
```

## 元组

```PYTHON
1.创建空元组
info_tuple=()
2.创建只含有一个元素的元组，需要在元素后面添加逗号
info_tuple=(1,)

不能进行修改的操作
```

### 元组合列表之间的相互转换

```PYTHON
list(元组)  # 将元组转换成列表
tuple(列表) # 将列表转换成元组
```

## 字典

```PYTHON
1.字典是用来存储数据的一种容器(一般用来存储事物详细信息的容器)
2.通过键值对的方式来存储数据的
3.语法格式:  字典名 = {key1:value1, key2:value2, key3:value3 ...}
    空字典:  字典名 = {}
4.字典的类型  dict
5.字典的键 和 值 的数据格式
  字典的键(key) 只能是除了 列表 和 字典以外的任意数据类型 
  字典的value值可以是任意数据 类型
6.字典中的数据是无序,列表中数据有序
7.访问字典的数据
  通过key获取值   
  格式: 字典名[key]
```

#### 增/改

```PYTHON
① 字典名[key] = value,  
  key存在,修改数据,  
  key不存在, 新建键值对
② 字典名.setdefault(key, value)   
  key存在,不修改数据,(使用默认值), 
  key不存在, 新建键值对
③ 字典1名.update(字典2)   # 把字典2合并到字典1中去,  
  字典1中 key存在,更新数据,  
  字典1中 key不存在, 新建键值对
```

#### 删

```PYTHON
①  del  字典名[key] 
    key存在, 删除 key对应的键值对
    key不存在,报错
② 字典名.pop(key)
    key存在, 删除 key对应的键值对
    key不存在,报错
③ 字典名.popitem()   随机删除键值对
④ 字典名.clear()   把字典内容清空(字典结构依然存在)
```

#### 查

```PYTHON
① 字典名[key]       
  key存在 正常取值, 
  key不存在,报错 (报错后面的代码不再执行)
② 字典名.get(key)   
  key存在 正常取值, 
  key不存在,不会报错, 返回 None (报错后面的代码可以继续执行)
```

### 字典的高级用法

```PYTHON

1.len(字典名)  获取的字典中键值对的个数
2.高级用法
  ① 字典名.keys()    获取所有的键(key) 组成的特殊的列表
  ② 字典名.values()  获取所有的值(value) 组成的特殊的列表
  ③ 字典名.items()   获取所有的键(key)和值(value) 组成元组, 元组组成的特殊的列表
```

## 字符串

```python
1.作用: 就像列表一样用来存储数据的一种容器,主要是用来存储文本数据
2.列表是序列化的容器, 字符串也是序列化的容器(支持索引访问)
3.定义字符串的格式:
  ① 字符串名 = "xxx"  或 字符串名 = 'xxx'
  ② 字符串名 = """xxx"""  或 字符串名 = '''xxx'''
4.访问字符串的数据
  通过索引访问数据  
  格式:  字符串名[索引]      
  注意:  使用索引访问数据时,不要越界
5.字符串常见使用操作
  # 访问字符串
  ① 通过索引访问数据  字符串名[索引]
  ② 通过数据获取索引  字符串名.index(小字符串)  获取小字符串在大字符串中第一次出现索引位置
  拓展: 通过索引访问数据 ,不能修改字符串中数据
  # 统计
  获取字符串的长度 len(字符串名)
  获取大的字符串中小字符串的个数  字符串名.count(小字符串) 
6.可以使用for循环遍历字符串
7.字符串常见方法操作_判断类型
8.字符串判断类型的方法有很多，常用的有str.isspace(),str.isdigit(),str.islower(),str.isupper()
9.字符串的查找和替换方法中,str.startswith(substr),str.endswith(substr),str.find(substr),str.replace(old_str,new_str,num=string.count(old))
10.字符串的大小写转换中,常用的方法str.title(),str.lower(),str.upper()
11.字符串可以使用str.ljust(width)和str.rjust(width)实现文本对齐,str.center(width)实现字符串文本居中
12.字符串去空白字符,常常使用str.lstrip(),str.rstrip(),str.strip()
13.字符串常见的切分和拼接,str.split(substr,count)切分,str.splitlines()按行切分, new_str.join(str)字符串拼接
14.字符串是不可变对象,一般使用提供方法的修改
```

## 切片

```PYTHON
适用范围：字符串，列表，元组
##字符串的切片
1.作用:从大字符串中切出小字符串
2.格式: 字符串[开始索引 : 结束索引: 步长 ]

  包含开始位置索引, 不包含结束位置索引  [开始索引,  结束索引)

  步长默认是正1,可以省略, 步长前面的冒号可以省略

3.正序切片,从左往右,开始位置索引就是字符串开头,则开始位置索引可以省略

4.正序切片,从左往右,结束位置索引就是字符串末尾,则结束位置索引可以省略

5.正序切片,从左往右,默认步长为正1,则默认步长可以省略

6.正序切片,从左往右,默认步长为正1,则默认步长可以省略, 步长前面冒号也可以省略

7.倒序切片,从右往左,如果开始索引就是字符串的末尾, 则开始索引可以省略, 开始索引为-1，步长为-1,步长不能省略

8.当索引涉及到字符串的边界时,才可以考虑省略索引
```

## Python种常见的内置函数

```PYTHON
1.len()函数可以获取容器中元素的个数(获取字典中键值对的个数)
2.del()可以删除容器中指定的元素,可以使用关键字del 容器,还是可以使用del()函数,
    注意:del删除目前只是支持列表,还支持字典
3.max()求取容器中元素最大值,如果遇到字符串,则获取的是字符对应的ASCII的最大值
4.min()求取容器中元素最小值,如果遇到字符串,则获取的是字符对应的ASCII的最小值
```

## 变量及函数的高阶用法

### 查看变量地址的函数

id(变量)

###可变类型和不可变类型

```PYTHON
可变类型：列表，字典(里面的数据可以进行修改)
不可变类型：列表，字符串，数字类型(int,float,bool)
```

### 局部变量和全局变量

```PYTHON
局部变量：定义在函数内部的变量，不同的函数中变量名可以重复，不受影响
全局变量：定义在所有函数外部的变量，函数内部不能修改，函数内部如果想修改全局变量需要在变量前面加一个global声明，一般在开发中不用全局变量，如果用的话一些公司规定在命名全部变量的前面加上g_或gl_
##案例1
def demo(num,num_list):
    print("函数内部代码")
    num+=num
    # num_list.extend(num_list),函数执行结束后，外部数据同样会发生变化
    num_list+=num_list
    print("内部函数完成")
g_num=9
g_num_list=[1,2,3]
demo(g_num,g_num_list)
print(g_num)
print(g_num_list)
```

### 函数的高阶用法

```PYTHON
函数有几个返回值需要找几个变量接收
##缺省参数
1.概念：定义函数时，可以给某个参数指定一个默认值，具有默认值的参数就叫缺省参数
2.作用：调用函数的时候，如果没有给缺省参数传值，则在函数内部使用定义函数时指定的参数值，如果调用函数时传值，则函数内部使用传入的缺省参数的值
3.一般将常用的值设置为缺省参数，如果参数的值不确定，不介意设置缺省参数值
###缺省参数的注意事项：
1.带有默认值的缺省参数，在参数列表末位
eg:def test01(a,b=2)
2.调用函数时如果有多个缺省参数，最好指定参数名，这样解释器才能知道参数的对应关系
eg:def test(a,b=1,c=2):
    print("我是%d" % b)
    print("我是%d" % c)
test(3,b=4,c=5)
##多值参数
1.命名：多值参数命名时，习惯
*args:存放元祖参数；**kwargs:存放字典参数
案例1:
def test(a,*args,**kwargs):
    print(a)
    print(args)
    print(kwargs)
test(1,2,3,4,5,name="小明",age=18)
案例2：计算任意多个数字的和
def sum_number(*args):
    sum=0
    for i in args:
        sum+=i
    print(sum)
sum_number(2,3,4,5,6)

###字典和元组的拆包
作用：需要给元组/字典变量传递给函数指定的参数时使用
案例：
def sum_number(*args,**kwargs):
    print(args)
    print(kwargs)
g_num=(1,2,3)
g_info={"name":"小明","age":19}
sum_number(*g_num,**g_info)

```

### 函数的递归

```PYTHON
1.概念：函数调用自身的编程技巧称为递归
2.特点：一个函数内部调用自己
3.代码特点：函数内部的代码是相同的，知识针对参数不同函数处理结果不同，当参数满足一个条件时函数不再执行
实例1：
def sum_number(num):
    print(num)
    if num==1: # 递归函数的出口
        return
    sum_number(num-1)
sum_number(3)
案例2：计算1+2+3+4+5+....+sum
def sum_number(num):

    if num==1: # 递归函数的出口
        return 1
    tempt=sum_number(num-1)
    return num+tempt

result=sum_number(sum)
print(result)
```

### 匿名函数

```PYTHON 
语句：lambda arg1,arg2,arg3,....argn:表达式
实例：
sum=lambda a,b:a+b
print("result=%s" % sum(1,2))
```

## 文件操作

### 文件的概念

```PYTHON
##文件:
1.计算机中文件,就是存储在持久存储设备(长期存储设备)上的数据
2.长期存储设备:硬盘,U盘,移动硬盘,光盘
3.将数据长期的保存下来,在需要的时候使用

##文件的存储方式:
计算机中文件的数据,最终都是以二进制的格式来保存的

##文件分类
1.文本文件
  可以使用文本编辑器打开的文件
  .txt文件, .py文件
  本质上还是二进制文件(最终都要保存到硬盘上)
2.二进制文件
  不能使用文本编辑器打开,可以使用专门的软件打开的文件
  图片文件(.jpg,.png,.gif) 音视频文件, excel文件
```

### 操作文件的1函数3方法

```PYTHON
操作文件的流程:
1.打开文件
2.操作文件
  读  把文件内容读取到内存
  写  把内存中数据写入到文件中  (文件放在硬盘上)
3.关闭文件

操作文件的函数/方法:
1.open()函数:
  作用: 打开文件
  文件存在,正常打开, 返回文件操作对象
  文件不存在,报错
  说明: windows系统打开文件时,需要指定编码格式  encoding="utf-8"
        linux/unix 系统 打开文件时,不需要指定编码格式(默认就是utf-8编码)
2.read() 方法
  作用: 读取文件的内容 一次性全部读取
3.close() 方法
  作用: 关闭文件  造成系统资源的浪费 (一个运行的程序最多打开1024个文件)
案例：
# 1.打开文件
file=open("文件名") # 如果不在当前目录需要加上文件路径
#读文件
file.read()
# 关闭文件
file.close()
```

## 打开文件的三种方式

```PYTHON
打开文件的三种方式:
"r" : 只读
 文件存在, 从开头读
文件不存在, 报错

"w": 只写
文件存在, 覆盖
文件不存在, 新建

"a": 追加
文件存在,在文件末尾追加数据
文件不存在,新建

注意: 频繁移动文件指针会降低文件读写效率,一般情况使用只读或只写方式打开文件
    
readline() 方法 
作用: 一次读取一行, 读取完成以后把文件指针移动文件的下一行
为了读取大文件内容,需要和配合while True一起使用
实例：大文件按行读取
# 1.打开文件
file=open("cards_main.py")
while True:
    # 2.按行读取文件
    text=file.readline()
    # 3.判断是否读到内容
    if not text:
        break
    # 每读取一行的末位已经有一个换行符"\n"
    print(text,end="")
# 4.关闭文件
file.close()

案例2：文件复制
# 1.打开文件
file=open("文件")
file_write=open("文件_复制","w")

# 2.读取文件并写入文件
while True:
    text=file.readline()
    # 3.判断是否读到内容
    if not text:
        break
    file_write.write(text)
# 4.关闭文件
file.close()
file_write.close()
```

### OS的基本用法

```PYTHON
os模块操作文件:
1.rename 重命名文件, os.rename(源文件名, 目标文件名)
  rename还可以重命名文件夹
2.remove 删除文件, os.remove(文件名)
  可以指定路径去删除文件

  os模块中对文件夹的操作
# 01 listdir 获取目录列表  os.listdir(目录名)
获取的是指定目录下的所有的文件和文件夹, 以列表的格式保存
02 mkdir 创建目录 os.mkdir(目录名) 
   # 可以指定路径创建目录
03 rmdir 删除目录 os.rmdir(目录名)
   注意: rmdir 只能删除空目录
   注意: 可以使用  shutil模块中rmtree() 删除非空目录
04 getcwd 获取当前目录 os.getcwd()
05 chdir 修改工作目录 os.chdir(目标目录)
06 path.isdir 判断是否是文件夹   os.path.isdir(文件夹路径)
是文件夹  返回True
不是文件夹  返回False
07 path.exists(目录/文件)   判断指定的目录或文件是否存在,  存在 返回True, 否则返回False

案例1：批量创建文件重命名文件
"""
批量修改文件名
 1.创建一个目录在该目录下创建20个文件
2.将这20个文件重命民
"""
import os
os.mkdir('A') # 创建目录
os.chdir('./A') # 修改目录
def create_file():
    i=1
    while i<=20:
        file=open("file"+str(i),'w')
        file.write('我命由我不由天')
        file.close()
        i+=1
def rename_file():
    dic_file=os.listdir() # 获取文件列表
    for name in dic_file:
        os.rename(name,'[rename]'+name)
create_file()
rename_file()
```

### os的高级用法

```python
- [ ] Import os，#导入标准库os模块，利用其中的API
python路径拼接os.path.join()函数的用法
os.path.join()函数：连接两个或更多的路径名组件
   1.如果各组件名首字母不包含’/’，则函数会自动加上
　2.第一个以”/”开头的参数开始拼接，之前的参数全部丢弃,当有多个时，从最后一个开始
　3.如果最后一个组件/为空，则生成的路径以一个’/’分隔符结尾

print("2:",os.path.join('/aaaa','/bbbb','/ccccc.txt')) #不良写法习惯

>>>2: /ccccc.txt

print("22:",os.path.join('/aaaa/','bbbb/','ccccc.txt')) #通常可以这样写

>>>22: aaaa/bbb/ccccc.txt

path1='/aaaa'
path2='/bbbb'
path3='/cccc'
path10=path1+path2+path3
print(path10)
/aaaa/bbbb/cccc

path1='/aaaa'
path2='/bbbb'
path3='/cccc'
path20=os.path.join(path1,path2,path3)
print(path20)
/cccc


path1='/aaaa/'
path2='bbbb/'
path3='cccc'
path20=os.path.join(path1,path2,path3)
print(path20)
/aaaa/bbbb/cccc

os.path.expanduser(path)  将路径中的～转换成user目录
import os
path='~/baidu.com'
tmp=os.path.expanduser(path)
print(tmp)
/Users/qingclass/baidu.com

os.path.join(path)  #把目录和文件名合成一个路径
os.path.exists(path) #判断文件是否存在

```

### eval()函数的用法

```PYTHON
eval()函数将字符串当做有效的表达式, 进行计算
把字符串两边的双引号去掉, 双引号中内容是什么 ,eval()函数返回的结果就是什么

不要滥用eval()函数
注意: 使用eval()函数对input()函数结果直接进行转换
很危险
案例：
result=eval("1+1")
print(result)
list_1=eval("[1,2,3,4,5]")
print(list_1)
print(type(list_1))
dict1=eval('{"age":18,"name":"小红"}')
print(dict1)
print(type(dict1))
```

## 类和对象

```PYTHON
##面向过程:  (流水线思维方式)
1.让小哥去买雪碧, 他去买雪碧的过程都是精确控制的,从头到尾一步一步去完成
2.吃烤鸭, 自己去养鸭子,杀鸭子,自己烤鸭子.自己吃.中间过程每一个步骤都是自己去实现

特点:
1.过于注重步骤和过程, 不注重职责分工
2.如果代码需求很复杂, 代码不便于管理
3.开发复杂项目,没有固定套路,不适合开发大型项目

##面向对象: ( 上帝式思维方式)
1.让小哥去买雪碧,不需要精确控制买雪碧的过程, 由小哥自己去决定
2.吃烤鸭, 自己去卖鸭子的店里买烤鸭. 烤鸭的制作过程有店里老板完成,
  我们自己不需要参与

特点: 
1.注重 对象和职责, 不同的对象完成不同的功能
2.更加适合复杂的业务需求, 尤其是大型项目
3.面向对象 的编程思维方式在 面向过程  的编程思维方式基础之上


类:( 飞机图纸 类)
1.具有相同特征和行为的统称, 是一个抽象的概念
  特征----> 属性---->  变量     飞机的长宽高
  行为----> 方法-----> 函数     飞机 可以飞翔, 翻阅

对象: (一架架飞机)
1.对象就是由类创建出来的一个个具体存在的事物
 对象中具有类的属性和方法


人类:
特征: 一个鼻子,两只眼睛,一个嘴巴,两个耳朵 -----> 特征---> 属性---> 变量
行为: 吃, 走, 睡觉, 工作 ----- > 行为 -----> 方法 ----> 函数

对象:
坐着的小明  开车的小王  唱歌的小红
对象中都有自己的属性和方法
每个对象的属性和方法的结果可能各不相同


类和对象的关系:
1.类是模板, 通过类可以创建出来一个个具体存在的对象.
2.先有类,再有对象( 对象是由类创建出来的)
3.类一般只有一个, 对象可以有多个
4.类中有的属性和方法, 对象也具有属性和方法


设计类满足的三要素:
1.类名,这类事物抽象的统称,是这类事物的名字,
  要满足大驼峰命名法(每个单词的首字母都要大写)
2.属性----这类事物具有的特征----> 名词,静态的特征
3.方法----这类事物具有的行为----> 动词,动态的行为


# 类的设计
小明 -----> 姓名, 特征---> 属性
18岁 -----> 年龄, 特征---> 属性
1.75------> 身高, 特征---> 属性
跑 ------->       行为---> 方法
吃  ------>       行为---> 方法

小美 -----> 姓名, 特征---> 属性
17岁 -----> 年龄, 特征---> 属性
1.65------> 身高, 特征---> 属性
跑 ------->       行为---> 方法
吃  ------>       行为---> 方法


人类:
姓名
年龄
身高
跑
吃 

Person:
name
age
high
run()
eat()

##dir()函数
1.python中内置的函数
2.可以来查看变量/对象/数据 的所有属性和方法
```

### 类

```python
1.语法:
class 类名:
    def 方法名1(self, 参数列表):
        print("---方法执行语句代码---")

    def 方法名2(self, 参数列表):
        print("---方法执行语句代码---")
2.类名要符合大驼峰命名法


# 方法和函数的区别:
1.定义的位置不同:
函数定义在类外
方法定义在类内部
2.参数不同:
函数没有参数 self
方法有参数 self
3.调用方式不同
函数:  函数名( 参数列表 )
方法:  对象名.方法名( 参数列表 )

#类创建对象:
对象变量名 = 类名()
对象变量名保存的是对象内存地址的引用

案例：
class Cat:
    """定义一个猫类"""
    def eat(self):
        print("小猫爱吃鱼")
    def drink(self):
        print("小猫爱喝水")
tom=Cat()
tom.eat()
tom.drink()

方法的调用顺序:
1.Python解释器遇到定义类时,会进入类的内部定义类模板, 
但是不会进入方法体内部执行方法体中的代码
2.如果在类外, 使用对象.方法名()  
  调用方法时, 才会进入类内方法体中执行 方法体中的代码
3.当类内 方法体内部代码执行完毕以后,
  回到方法调用的地方继续向下执行

地址的进制表示:
1.十进制   %d
2.十六进制 %x
获取变量的引用的内存地址  id(变量)

# 给对象添加属性有两种方式:
1.在类外部给对象添加属性
  方式:  对象.属性名 = 值
  添加完属性后,访问方式:
  1).在类的内部   可以使用self参数访问属性   self.属性名
  2).在类的外部   通过对象访问属性         对象名.属性名
2.在类内部给对象添加属性  -- > 待定


重点:
self参数的小结:
1.self保存当前对象地址的引用(哪个对象调用方法,self就保存哪个对象的引用地址)
2.属性的访问:
  在类内部 可以使用self参数访问属性  self.属性名
  在类的外部 使用对象访问属性  对象.属性名
3.方法的访问:
   在类内部 通过self参数访问方法   self.方法名()
   在类外部 通过对象调用方法      对象名.方法名()
    
    
匿名函数:
1.匿名函数( lambda表达式 )
2.作用: 省略def 关键字定义函数的标准步骤, 可以快速的定义功能简单的函数
3.语法:  lambda  参数 / 多个参数 : 表达式




```

### __init__  ,del,str方法

```PYTHON
__init__方法是魔法方法(内置方法), 当创建对象时,自动调用
作用:就是 初始化数据
创建对象时(使用 类名()  ):
1.创建对象时,先分配内存空间
2.再初始化内存空间中数据


在类内部给对象添加属性
1.在__init__方法中添加 属性   self.属性名 =  属性值
2.类外访问属性  对象.属性名
3.类内访问属性  self.属性名

初始化的同时设置属性值:
1.在初始化方法__init__中添加属性参数 __init__(self, 属性参数)
2.在初始化方法中 把属性参数作为属性保存  self.属性 = 属性参数
3.使用类创建对象时 Cat(参数列表)


魔法方法:
__del__ 魔法方法 对象被从内存中销毁前， 会被自动调用
__str__  魔法方法:
1.使用print打印对象时, __str__方法会自动调用
2.作用: 打印对象的描述信息
3.注意:  __str__方法 只能返回字符串
实例：
class Cat:
    def __init__(self,name):
        print("我是初始化方法:%s" % name)
        self.name=name
    def eat(self):
        print("小猫喜欢吃鱼")
tom=Cat("TOM")
tom.eat()
```

### 面向对象封装

```PYTHON
案例1：小明原体重56.78，跑步减0.5斤，吃增1斤
class Person:
    def __init__(self,name,weight):
        self.name=name
        self.weight=weight
    def __str__(self):
        return "%s体重是%.2f" %(self.name,self.weight)
    def run(self):
        print("%s爱跑步"% self.name)
        self.weight -=0.5
    def eat(self):
        print("%s爱吃"% self.name)
        self.weight +=1
person=Person("小明",56.78)
person.run()
person.eat()
print(person)
```

### 身份运算符

```python
身份运算符
is 用来判断两个变量引用地址是否相同  如果相同反回True, 否则返回False
== 用来判断两个变量的数据值是否相等  如果相等反回True, 否则返回False
```

### 私有属性和私有方法

```PYTHON
1.有些情况下,类中一些属性和方法不需要类外直接访问到,可以把类中的属性和方法定义为
私有
2.前置双下划线的属性和方法就是私有属性和私有方法, 
  __age 私有属性,  __screat(self) 私有方法
3.私有属性和私有方法在类外部不能直接访问,
  但是可以在类内部访问到  可以通过self访问
4.Python中并没有真正意义上的私有属性和私有方法, 
  而是通过名字重整的方式将私有属性和私有方法改了名字
  方式: 
    ① 私有属性名: _类名__私有属性名  
    ② 私有方法名: _类名__私有方法名
5.可以通过重整后的私有属性名和私有方法名,间接去访问
6.Python中的警告: Python中不阻止你去干坏事,一切靠自觉
7.可以通过对外方法间接访问私有属性, set_age()/ get_age()
```

#### 异常

```python
异常:
1.程序执行过程中,python解释器遇到错误,程序不再向下执行,并且提示错误信息,这就是异常
2.程序不再向下执行,并且提示错误信息的动作, 就是抛出(raise)异常
3.出现异常需要捕捉异常,为什么? 程序开发人员无法消灭异常(比如网络不稳定),
  只能靠捕捉异常,并对捕捉到的异常进行相应处理(图片加载失败,要提示相应的错误信息)

异常的捕获:
1.使用try...except来捕获异常并处理异常,把可能出现异常的代码放在try缩进部分
2.except部分的代码只有在发生异常时才会执行,可以处理异常修复或信息提示
3.只要捕捉了异常,不管异常是否发生,程序都可以正常结束
4.在try语句中出现异常,异常后面的代码不再执行
5.捕获指定异常时,在except后面添加异常类型
  格式: except 异常类型
6.对同一个异常捕获多次,只执行第一次捕获的异常代码
7.一次捕获多个异常  格式: except ( 异常类型1, 异常类型2, ...):
  作用: 对不同的异常有相同的处理结果
8.捕获任意类型异常  格式: except Exception:
9.获取异常的错误信息,给异常类型起别名,
  except 异常类型名 as  别名
   (别名中记录异常的错误信息)


异常的完整语法:
1.格式: 
try:
    # 可能会出现异常的代码
except 异常类型1:
    # 针对异常类型1的处理代码
except 异常类型2:
    # 针对异常类型2的处理代码
except (异常类型3,异常类型4):
    # 针对异常类型3或异常类型4的处理代码
except Exception as exp:
    # exp中获取异常的错误信息
    # except部分只有在发生异常时才会执行
else:
    # else部分在没有发生异常时才会执行
finally:
    # finally部分无论有没有异常都会执行..

2.应用场景,在打开文件向文件写入数据时程序崩溃,
  此时可以在finally部分添加关闭文件资源的操作,避免系统资源浪费


异常的传递:
1.如果在被调用的函数中有异常没有捕获处理,则会把异常传递给调用的地方
2.最终传递到Python解释器依然没有捕获异常,则程序崩溃


抛出异常:
1.创建Exception异常类的对象  有参数:字符串
2.使用raise抛出异常,语法: raise Exception("异常的错误提示信息")
```

### 模块

```python

模块:
1.以.py结尾的文件原则上都可以作为模块使用,把成熟稳定的代码封装到模块中,
   便于其它开发者使用
2.模块名必须符合标识符的命名规范,(由数字,字母,下划线组成,并且不能以数字开头)
3.模块中可以封装全局变量,函数,类等,当做工具可以提供给其它开发者使用
4.使用模块,则需要:
  1).先导入模块 import 模块名
  2).使用模块中工具,  模块名.全局变量名,模块名.函数名()   模块名.类名()


5.如果模块名太长,可以使用as给模块起别名,
   ① 格式: import 模块名 as 模块别名
   ② 注意: 模块别名要符合大驼峰命名法则

6.注意: from ...import导入模块中工具(全局变量,函数,类),
  格式:  from  模块名  import 工具名
  如果工具名相同,后导入的工具名会覆盖之前导入的工具名
  解决办法: 用as给工具名起新的别名

7.还可以使用 from...import * 导入模块中工具 
  ,这种方式可以将模块中所有的全局变量,函数,类都作为工具导入
  注意: 不推荐使用,因为函数重名并没有任何的提示,出现问题不好排查



导入模块的两种方式:
1.import 模块名
    特点: 将模块中所有的全局变量,函数,类全部导入
    访问方式: 模块名.全局变量  模块名.函数()   模块名.类名()
2.from 模块名 import 全局变量/函数/类名
    特点: 将所需要的全局变量/函数/类名导入
    访问方式: 直接使用  全局变量名/函数()/类名()



模块的搜索顺序:
1.导入模块时,现在当前目录下查找,如果查找到了,就导入
2.如果当前目录下没有找到模块,则导入系统模块
3.可以使用__file__属性查看模块的路径,使用方式:模块名.__file__
4.在开发时,给文件起名,不要和系统的模块文件名相同



__name__内置属性:
1.__name__内置属性可以做到,模块代码在测试情况下执行,而在被导入情况下不会执行
2.如果在当前文件中直接打印__name__内置属性,则直接输出字符串__main__
3.如果当前文件被当做模块导入,在导入的文件中直接运行时,则__name__内置属性 
  输出的就是当前被导入的模块名
4.如果要做到代码在测试情况下执行,而不会在导入情况下执行,
  要在当前文件中添加if条件判断 if  __name__ == "__main__":



包:
1.包是包含很多模块的特殊的目录
2.包中包含__init__.py文件
3.我们可以把包直接给调用者,调用者导入包后,可以获取到包中所有的模块
  导入包的方式: import 包名
4.创建包的两种方式:
  ① 在PyCharm中新建一个文件夹,在文件夹新建文件__init__.py
  ② 在PyCharm中可以直接新建 Python Package
5.如果想要把包给其它开发者导入使用,__init__.py 中指定 对外界提供的模块列表
  需要在  __init__.py文件中添加
    from  .  import  模块名
6.导入包方式:
    ① import 包名
      import 包名.模块名
    ② from 包名 import 模块名
    ③ from 包名.模块名 import 函数名/类名
  
```

## 继承

### 面向对象三大特征

```PYTHON
1.封装 根据职责将属性和方法封装到一个抽象的类中

2.继承 实现代码的重用，相同的代码不需要重复编写

3.多态 不同的对象调用相同的方法，产生不同的执行结果，增加代码的灵活度

```

### 单继承

```python
单继承的概念：子类拥有父类的所有方法和属性
语法：class 类名(父类名)：
		pass
特点：1.传递性：A继承B,B继承C,A具有BC的属性和方法
	 2.可以重写父类：当父类的方法不能满足子类的话，可以对方法进行重写
    重写分为两种：1.覆盖父类，2.扩展父类
    第1种的应用场景：父类的方法实现与子类的方法实现完全不同
    第2种的应用场景：子类的方法实现中包含父类的方法实现，调用：super().父类方法，调用父类方法的执行
```

### 多继承

```python
多继承概念：子类可以继承多个父类，并且拥有所有父类的属性和方法
语法：class 类名(父类名1，父类名2，......)：
		pass
```

定义类的时候，如果没有父类

语法：class 类名（object）

​		pass



##获取隐藏元素的文本信息

```python
  is_displayed()  为false的元素,依然可以通过getAttribute()方法获取元素的属性. 

     由于webdriver spec的定义，Selenium WebDriver 只会与可见元素交互，所以获取隐藏元素的文本总是会返回空字符串

  想要获取隐藏元素的文本，可以使用element.attribute('attributeName'), 通过textContent, innerText, innerHTML等属性获 取。(划重点)

innerHTML 会返回元素的内部 HTML， 包含所有的HTML标签。 

例如，<div>Hello <p>World!</p></div>的innerHTML会得到Hello <p>World!</p>

textContent 和 innerText 只会得到文本内容，而不会包含 HTML 标签。 

textContent 是 W3C 兼容的文字内容属性，但是 IE 不支持

innerText 不是 W3C DOM 的指定内容，FireFox不支持
```



